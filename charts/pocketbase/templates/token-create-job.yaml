apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ include "pocketbase.fullname" . }}-token-job-sa
  labels:
    app.kubernetes.io/name: pocketbase
    app.kubernetes.io/instance: {{ .Release.Name }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ include "pocketbase.fullname" . }}-token-job-role
  labels:
    app.kubernetes.io/name: pocketbase
    app.kubernetes.io/instance: {{ .Release.Name }}
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "create", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ include "pocketbase.fullname" . }}-token-job-rb
  labels:
    app.kubernetes.io/name: pocketbase
    app.kubernetes.io/instance: {{ .Release.Name }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ include "pocketbase.fullname" . }}-token-job-role
subjects:
  - kind: ServiceAccount
    name: {{ include "pocketbase.fullname" . }}-token-job-sa
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "pocketbase.fullname" . }}-token-create
  labels:
    app.kubernetes.io/name: pocketbase
    app.kubernetes.io/instance: {{ .Release.Name }}
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-delete-policy": hook-succeeded
spec:
  backoffLimit: {{ .Values.token.job.backoffLimit | default 3 }}
  template:
    spec:
      serviceAccountName: {{ include "pocketbase.fullname" . }}-token-job-sa
      restartPolicy: OnFailure
      containers:
        - name: token-creator
          image: "{{ .Values.token.job.image | default "bitnami/kubectl:1.27.3" }}"
          imagePullPolicy: IfNotPresent
          env:
            - name: POCKETBASE_URL
              value: "{{ printf "http://%s:%d" (include "pocketbase.fullname" .) .Values.service.port }}"
            - name: ADMIN_EMAIL
              valueFrom:
                secretKeyRef:
                  name: {{ include "pocketbase.fullname" . }}-admin
                  key: email
            - name: ADMIN_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ include "pocketbase.fullname" . }}-admin
                  key: password
            - name: NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          command:
            - /bin/sh
            - -c
            - |
              set -euo pipefail
              SECRET_NAME="{{ if .Values.token.secretName }}{{ .Values.token.secretName }}{{ else }}{{ include "pocketbase.fullname" . }}-token{{ end }}"
              RETRIES={{ .Values.token.job.retries | default 30 }}
              SLEEP={{ .Values.token.job.sleepSeconds | default 2 }}
              i=0
              echo "waiting for PocketBase at $POCKETBASE_URL ..."
              until [ $i -ge $RETRIES ]
              do
                if curl -s -f "$POCKETBASE_URL/" >/dev/null 2>&1; then
                  echo "pocketbase reachable"
                  break
                fi
                i=$((i+1))
                sleep $SLEEP
              done
              if [ $i -ge $RETRIES ]; then
                echo "timeout waiting for PocketBase"
                exit 1
              fi
              # if secret already exists, do nothing (idempotent)
              if kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
                echo "token secret $SECRET_NAME already exists; skipping creation"
                exit 0
              fi
              # authenticate admin and extract token (try a couple of response shapes)
              resp=$(curl -s -X POST -H "Content-Type: application/json" -d "{\"identity\":\"$ADMIN_EMAIL\",\"password\":\"$ADMIN_PASSWORD\"}" "$POCKETBASE_URL/api/admins/auth-with-password")
              # try to extract token using crude parsing to avoid jq dependency
              token=$(echo "$resp" | tr -d '\n' | sed -E 's/.*"token":"([^"]+)".*/\1/;t; s/.*"data":\{.*"token":"([^"]+)".*/\1/;t; s/.*"token":\s*"([^"]+)".*/\1/;t; s/.*"data":\{.*"token":\s*"([^"]+)".*/\1/;t; s/.*"accessToken":"([^"]+)".*/\1/;t; s/.*/null/')
              if [ -z "$token" ] || [ "$token" = "null" ]; then
                echo "failed to obtain admin token; response: $resp"
                exit 1
              fi
              echo "got token, creating secret $SECRET_NAME"
              kubectl create secret generic "$SECRET_NAME" -n "$NAMESPACE" --from-literal=token="$token" --dry-run=client -o yaml | kubectl apply -f -
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
      tolerations:
        - operator: "Exists"